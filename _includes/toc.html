<!-- Table of Contents Generator -->
<div class="toc-container">
  <div class="toc-header">
    <h3>Table of Contents</h3>
  </div>
  <nav class="toc">
    <ul id="toc-list">
      <!-- TOC will be generated by JavaScript -->
    </ul>
  </nav>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // Generate table of contents
  const tocList = document.getElementById('toc-list');
  const headings = document.querySelectorAll('article h1, article h2, article h3, article h4, article h5, article h6');
  const tocSidebar = document.querySelector('.post-sidebar');
  const postTitle = document.querySelector('article h1');
  
  if (headings.length === 0) {
    document.querySelector('.toc-container').style.display = 'none';
    return;
  }
  
  // Calculate initial position based on post title
  function updateTocPosition() {
    if (postTitle && tocSidebar) {
      const titleRect = postTitle.getBoundingClientRect();
      const titleTop = titleRect.top + window.scrollY;
      const currentScroll = window.scrollY;
      
      // Position TOC to align with title when at the top
      // But keep it visible as user scrolls
      const minTop = 2; // Minimum distance from top of viewport (in rem)
      const titleOffset = Math.max(minTop * 16, titleTop - currentScroll); // 16px = 1rem
      
      tocSidebar.style.top = Math.min(titleOffset, titleTop - currentScroll + 16) + 'px';
      
      // If title is above viewport, keep TOC at top
      if (titleTop - currentScroll < minTop * 16) {
        tocSidebar.style.top = (minTop * 16) + 'px';
      }
    }
  }
  
  // Initial positioning
  setTimeout(updateTocPosition, 100);
  
  // Update position on scroll
  let scrollTimeout;
  window.addEventListener('scroll', function() {
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(updateTocPosition, 10);
  });
  
  // Update position on resize
  window.addEventListener('resize', updateTocPosition);
  
  let tocHTML = '';
  let currentLevel = 0;
  
  headings.forEach((heading, index) => {
    const level = parseInt(heading.tagName.charAt(1));
    const text = heading.textContent.trim();
    const id = 'heading-' + index;
    
    // Add ID to heading for linking
    heading.id = id;
    
    // Add anchor link to heading
    const anchor = document.createElement('a');
    anchor.href = '#' + id;
    anchor.className = 'heading-link';
    anchor.innerHTML = 'ðŸ”—';
    anchor.title = 'Link to this section';
    heading.appendChild(anchor);
    
    // Determine nesting level
    if (level > currentLevel) {
      for (let i = currentLevel; i < level; i++) {
        tocHTML += '<ul>';
      }
    } else if (level < currentLevel) {
      for (let i = level; i < currentLevel; i++) {
        tocHTML += '</ul>';
      }
    }
    
    tocHTML += `<li><a href="#${id}" class="toc-link" data-level="${level}">${text}</a></li>`;
    currentLevel = level;
  });
  
  // Close remaining ul tags
  for (let i = 0; i < currentLevel; i++) {
    tocHTML += '</ul>';
  }
  
  tocList.innerHTML = tocHTML;
  
  // Highlight current section on scroll
  const tocLinks = document.querySelectorAll('.toc-link');
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        tocLinks.forEach(link => link.classList.remove('active'));
        const activeLink = document.querySelector(`a[href="#${entry.target.id}"]`);
        if (activeLink) {
          activeLink.classList.add('active');
        }
      }
    });
  }, {
    rootMargin: '-20% 0% -35% 0%'
  });
  
  headings.forEach(heading => {
    observer.observe(heading);
  });
  
  // Smooth scrolling for TOC links
  tocLinks.forEach(link => {
    link.addEventListener('click', function(e) {
      e.preventDefault();
      const targetId = this.getAttribute('href').substring(1);
      const targetElement = document.getElementById(targetId);
      if (targetElement) {
        targetElement.scrollIntoView({
          behavior: 'smooth',
          block: 'start'
        });
      }
    });
  });
});
</script>