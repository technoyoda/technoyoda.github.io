<!-- Table of Contents Generator -->
<div class="toc-container">
  <div class="toc-header">
    <h3>Table of Contents</h3>
  </div>
  <nav class="toc">
    <ul id="toc-list">
      <!-- TOC will be generated by JavaScript -->
    </ul>
  </nav>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // Generate table of contents
  const tocList = document.getElementById('toc-list');
  const headings = document.querySelectorAll('article h1, article h2, article h3, article h4, article h5, article h6');
  const tocSidebar = document.querySelector('.post-sidebar');
  const postTitle = document.querySelector('article h1');
  
  if (headings.length === 0) {
    document.querySelector('.toc-container').style.display = 'none';
    return;
  }
  
  // Calculate initial position based on post title and move with scroll direction
  let initialScrollY = window.scrollY;
  let initialTocTop = 0; // TOC top relative to viewport at load, aligned with title
  const MIN_TOP = 2 * 16; // 2rem in px

  function measureInitial() {
    const titleRect = postTitle.getBoundingClientRect();
    initialTocTop = Math.max(MIN_TOP, titleRect.top);
    // Set initial top immediately
    tocSidebar.style.top = initialTocTop + 'px';
  }

  function updateTocPosition() {
    if (!(postTitle && tocSidebar)) return;

    const currentScrollY = window.scrollY;
    const delta = currentScrollY - initialScrollY; // positive when scrolling down

    // Move TOC in the same direction as scroll
    let nextTop = initialTocTop + delta;
    if (nextTop < MIN_TOP) nextTop = MIN_TOP;
    tocSidebar.style.top = nextTop + 'px';
  }
  
  // Initial positioning
  setTimeout(() => { measureInitial(); updateTocPosition(); }, 100);
  
  // Update position on scroll
  let scrollTimeout;
  window.addEventListener('scroll', function() {
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(updateTocPosition, 10);
  });
  
  // Update position on resize
  window.addEventListener('resize', () => { measureInitial(); updateTocPosition(); });
  
  let tocHTML = '';
  let currentLevel = 0;
  
  headings.forEach((heading, index) => {
    const level = parseInt(heading.tagName.charAt(1));
    const text = heading.textContent.trim();
    const id = 'heading-' + index;
    
    // Add ID to heading for linking
    heading.id = id;
    
    // Add anchor link to heading
    const anchor = document.createElement('a');
    anchor.href = '#' + id;
    anchor.className = 'heading-link';
    anchor.innerHTML = 'ðŸ”—';
    anchor.title = 'Link to this section';
    heading.appendChild(anchor);
    
    // Determine nesting level
    if (level > currentLevel) {
      for (let i = currentLevel; i < level; i++) {
        tocHTML += '<ul>';
      }
    } else if (level < currentLevel) {
      for (let i = level; i < currentLevel; i++) {
        tocHTML += '</ul>';
      }
    }
    
    tocHTML += `<li><a href="#${id}" class="toc-link" data-level="${level}">${text}</a></li>`;
    currentLevel = level;
  });
  
  // Close remaining ul tags
  for (let i = 0; i < currentLevel; i++) {
    tocHTML += '</ul>';
  }
  
  tocList.innerHTML = tocHTML;
  
  // Highlight current section on scroll
  const tocLinks = document.querySelectorAll('.toc-link');
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        tocLinks.forEach(link => link.classList.remove('active'));
        const activeLink = document.querySelector(`a[href="#${entry.target.id}"]`);
        if (activeLink) {
          activeLink.classList.add('active');
        }
      }
    });
  }, {
    rootMargin: '-20% 0% -35% 0%'
  });
  
  headings.forEach(heading => {
    observer.observe(heading);
  });
  
  // Smooth scrolling for TOC links
  tocLinks.forEach(link => {
    link.addEventListener('click', function(e) {
      e.preventDefault();
      const targetId = this.getAttribute('href').substring(1);
      const targetElement = document.getElementById(targetId);
      if (targetElement) {
        targetElement.scrollIntoView({
          behavior: 'smooth',
          block: 'start'
        });
      }
    });
  });
});
</script>